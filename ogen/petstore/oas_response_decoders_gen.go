// Code generated by ogen, DO NOT EDIT.

package petstore

import (
	"bytes"
	"io"
	"mime"
	"net/http"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func decodeAddPetResponse(resp *http.Response) (res *AddPetMethodNotAllowed, _ error) {
	switch resp.StatusCode {
	case 405:
		// Code 405.
		return &AddPetMethodNotAllowed{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeCreateUserResponse(resp *http.Response) (res *CreateUserDef, _ error) {
	// Default response.
	res, err := func() (res *CreateUserDef, err error) {
		return &CreateUserDef{
			StatusCode: resp.StatusCode,
		}, nil
	}()
	if err != nil {
		return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
	}
	return res, nil
}

func decodeCreateUsersWithArrayInputResponse(resp *http.Response) (res *CreateUsersWithArrayInputDef, _ error) {
	// Default response.
	res, err := func() (res *CreateUsersWithArrayInputDef, err error) {
		return &CreateUsersWithArrayInputDef{
			StatusCode: resp.StatusCode,
		}, nil
	}()
	if err != nil {
		return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
	}
	return res, nil
}

func decodeCreateUsersWithListInputResponse(resp *http.Response) (res *CreateUsersWithListInputDef, _ error) {
	// Default response.
	res, err := func() (res *CreateUsersWithListInputDef, err error) {
		return &CreateUsersWithListInputDef{
			StatusCode: resp.StatusCode,
		}, nil
	}()
	if err != nil {
		return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
	}
	return res, nil
}

func decodeDeleteOrderResponse(resp *http.Response) (res DeleteOrderRes, _ error) {
	switch resp.StatusCode {
	case 400:
		// Code 400.
		return &DeleteOrderBadRequest{}, nil
	case 404:
		// Code 404.
		return &DeleteOrderNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeDeletePetResponse(resp *http.Response) (res *DeletePetBadRequest, _ error) {
	switch resp.StatusCode {
	case 400:
		// Code 400.
		return &DeletePetBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeDeleteUserResponse(resp *http.Response) (res DeleteUserRes, _ error) {
	switch resp.StatusCode {
	case 400:
		// Code 400.
		return &DeleteUserBadRequest{}, nil
	case 404:
		// Code 404.
		return &DeleteUserNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeFindPetsByStatusResponse(resp *http.Response) (res FindPetsByStatusRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response FindPetsByStatusOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &FindPetsByStatusBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeFindPetsByTagsResponse(resp *http.Response) (res FindPetsByTagsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response FindPetsByTagsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &FindPetsByTagsBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeGetInventoryResponse(resp *http.Response) (res GetInventoryOK, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetInventoryOK
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeGetOrderByIdResponse(resp *http.Response) (res GetOrderByIdRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Order
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetOrderByIdBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetOrderByIdNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeGetPetByIdResponse(resp *http.Response) (res GetPetByIdRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Pet
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetPetByIdBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetPetByIdNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeGetUserByNameResponse(resp *http.Response) (res GetUserByNameRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response User
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetUserByNameBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetUserByNameNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeLoginUserResponse(resp *http.Response) (res LoginUserRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response string
			if err := func() error {
				v, err := d.Str()
				response = string(v)
				if err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			var wrapper LoginUserOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-Expires-After" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-Expires-After",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXExpiresAfterVal time.Time
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToDateTime(val)
								if err != nil {
									return err
								}

								wrapperDotXExpiresAfterVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XExpiresAfter.SetTo(wrapperDotXExpiresAfterVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-Expires-After header")
				}
			}
			// Parse "X-Rate-Limit" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-Rate-Limit",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXRateLimitVal int32
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToInt32(val)
								if err != nil {
									return err
								}

								wrapperDotXRateLimitVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XRateLimit.SetTo(wrapperDotXRateLimitVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-Rate-Limit header")
				}
			}
			return &wrapper, nil
		case ct == "text/plain":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := LoginUserOKTextPlain{Data: bytes.NewReader(b)}
			var wrapper LoginUserOKTextPlainHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-Expires-After" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-Expires-After",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXExpiresAfterVal time.Time
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToDateTime(val)
								if err != nil {
									return err
								}

								wrapperDotXExpiresAfterVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XExpiresAfter.SetTo(wrapperDotXExpiresAfterVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-Expires-After header")
				}
			}
			// Parse "X-Rate-Limit" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-Rate-Limit",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXRateLimitVal int32
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToInt32(val)
								if err != nil {
									return err
								}

								wrapperDotXRateLimitVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XRateLimit.SetTo(wrapperDotXRateLimitVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-Rate-Limit header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &LoginUserBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeLogoutUserResponse(resp *http.Response) (res *LogoutUserDef, _ error) {
	// Default response.
	res, err := func() (res *LogoutUserDef, err error) {
		return &LogoutUserDef{
			StatusCode: resp.StatusCode,
		}, nil
	}()
	if err != nil {
		return res, errors.Wrapf(err, "default (code %d)", resp.StatusCode)
	}
	return res, nil
}

func decodeStoreSubscribePostResponse(resp *http.Response) (res *StoreSubscribePostCreated, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response StoreSubscribePostCreated
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeUpdatePetResponse(resp *http.Response) (res UpdatePetRes, _ error) {
	switch resp.StatusCode {
	case 400:
		// Code 400.
		return &UpdatePetBadRequest{}, nil
	case 404:
		// Code 404.
		return &UpdatePetNotFound{}, nil
	case 405:
		// Code 405.
		return &UpdatePetMethodNotAllowed{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeUpdatePetWithFormResponse(resp *http.Response) (res *UpdatePetWithFormMethodNotAllowed, _ error) {
	switch resp.StatusCode {
	case 405:
		// Code 405.
		return &UpdatePetWithFormMethodNotAllowed{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeUpdateUserResponse(resp *http.Response) (res UpdateUserRes, _ error) {
	switch resp.StatusCode {
	case 400:
		// Code 400.
		return &UpdateUserBadRequest{}, nil
	case 404:
		// Code 404.
		return &UpdateUserNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}

func decodeUploadFileResponse(resp *http.Response) (res *ApiResponse, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ApiResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCode(resp.StatusCode)
}
